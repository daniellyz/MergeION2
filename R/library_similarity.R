#' Searching a query spectrum in a spectral library
#'
#' The function calculates spectral similarity of a query spectrum to an existing spectral library
#'
#' @param query_spectrum  Two-column data matrix. Two columns represent m/z and intensity of query tandem spectrum. At least 3 valid peaks should be provided
#' @param polarity A single character. Either "Positive" or "Negative". Ion mode of the query spectrum.
#' @param prec_mz Numeric. Precursor mass of query spectrum.
#' @param use.prec Boolean. If set to TRUE, precursor mass is used to "pre-query" the library
#' @param input_library A list generated by the function library_generator() or the name of mgf/msp/RData spectral library file
#' @param input_matrix Transformed spectral library by the function library2matrix
#' @param method Character. Similarity metrics
#' \itemize{
#'   \item{Matches:}{ Conting number of fragment or neutral loss matches}
#'   \item{Cosine:}{ Cosine similarity score based on intensity vectors of fragments. Same as dot product since both query and db spectra are normalized to 100.}
#'   \item{Spearman:}{ Spearman similarity based on intensity ranks of fragments.}
#'   \item{Euclidean:}{ Euclidean similarity based on intensity ranks of fragments.}
#'   \item{MassBank:}{Similarity score used by MassBank using weighted cosine score}
#'   \item{NIST:}{Similarity score used by NIST using weighted cosine score}
#'   
#' }
#' @param prec_mz_search Numeric. Absolute mass tolerance in Da for precursor mass search.
#' @param frag_mz_search Numeric. Absolute mass tolerance in Da for MS/MS peak matching.
#' @param min_frag_match Integer. Minimum matched peaks (or corresponding neutral losses) to make a match	
#' 
#' @return Scores similarity scores between query spectrum and each spectral library ID.
#'
#' @author Youzhong Liu, \email{Youzhong.Liu@uantwerpen.be}
#'
#' @examples
#' 
#' # Load database to object lib4:
#' data(Local_DB_RMassBank_Calibrated)
#' 
#' # Load query spectra
#' cocain_file <- list.files(system.file("spectra", package = "MergeION"),".msp", full.names = TRUE)[1]
#' query_spectrum = cocain_file$sp[[1]]
#' 
#' # Search in the spectra library without using precursor mass pre-search
#' scores = library_similarity(query_spectrum, polarity = "Positive", prec_mz = 313.067, use.prec = FALSE, 
#'                          input_library = lib4, input_matrix = NULL, 
#'                          method = "Matches", prec_ppm_search = 10, frag_mz_search = 0.01, min_frag_match = 5)
#' 
#' # Visualize the top candidate
#' library_visualizer(lib4, id = scores$ID[1], query_spectrum) 
#' 
#' @importFrom tools file_ext
#'
#' @export

library_similarity<- function(query_spectrum, polarity = "Positive", prec_mz = 100, use.prec = FALSE, 
                              input_library = NULL, input_matrix = NULL, 
                              method = c("Matches", "Cosine", "Spearman", "Euclidean", "MassBank", "NIST"), 
                              prec_ppm_search = 10, frag_mz_search = 0.005, min_frag_match = 6){
  
  options(stringsAsFactors = FALSE)
  options(warn=-1)
  
  if (!is.null(query_spectrum)){if (ncol(query_spectrum)<2){stop("Spectrum must have 2 columns m/z and intensity!")}}
  if (!(polarity %in% c("Positive", "Negative"))){stop("Polarity of query spectrum must be positive or negative")}
  if (min_frag_match<5){stop("min_frag_match should not be smaller than 5!")}
  
  ##############################
  ### Using New Input Library ##
  ##############################
  
  if (is.null(input_matrix)){
    
    if (is.character(input_library)){
      if (file_ext(input_library)!="mgf" & file_ext(input_library)!="msp" & file_ext(input_library)!="RData"){
      stop("The input library must be mgf, msp or RData format!")
    }}
  
    if (is.character(input_library)){
      if (file_ext(input_library)=="mgf"){
        input_library = readMGF2(input_library)}
      if (file_ext(input_library)=="RData"){
        input_library = load_object(input_library)}
      if (file_ext(input_library)=="msp"){
        input_library = readMSP2(input_library)}
     }
  
    if (!is.null(input_library)){
      if (length(input_library)==2 & "complete" %in% names(input_library)){
        input_library = input_library$complete
      }
      if (length(input_library)!=2 || (!is.list(input_library$sp)) || !is.data.frame(input_library$metadata)){
        stop("Please make sure your input library is a valid output of library_generator()!")
      }
    } else {stop("Please provide input library!")}
  
    input_library = library_manager(input_library, query = paste0("IONMODE=", polarity))$SELECTED
  
    if (use.prec){input_library = library_manager(input_library, query = paste0("PEPMASS=", prec_mz), ppm_search = prec_ppm_search)$SELECTED}
  
    if (nrow(input_library$metadata)==0){return(NULL)}
    
    if (nrow(input_library$metadata)>0){
      input_matrix = library2matrix(input_library, consensus_window = 0.01)
      sp_profile = input_matrix$sp_profile
      sp_feature = input_matrix$sp_feature
      nl_profile = input_matrix$nl_profile
      nl_feature = input_matrix$nl_feature
    }
  
  ###########################################
  ### Using Existing Library (e.g MassBank) #
  ###########################################

  } else {

    input_library = input_matrix$ref_lib
    sp_profile = input_matrix$sp_profile
    sp_feature = input_matrix$sp_feature
    nl_profile = input_matrix$nl_profile
    nl_feature = input_matrix$nl_feature
    
    if (use.prec){
      input_library = library_manager(input_library, query = paste0("PEPMASS=", prec_mz), ppm_search = prec_ppm_search)
      valid = match(as.character(input_library$ID_SELECTED), as.character(input_matrix$ref_lib$metadata$ID))
      if (length(valid)==0){return(NULL)}
      
      input_library = input_library$SELECTED
      sp_profile = input_matrix$sp_profile[,valid,drop=FALSE]
      sp_feature = input_matrix$sp_feature
      nl_profile = input_matrix$nl_profile[,valid,drop=FALSE]
      nl_feature = input_matrix$nl_feature
    }
  }
  
  ###############################
  ### Reduce Existing Library####
  ###############################
  
  colnames(sp_feature) = colnames(nl_feature) = c("ID", "Mass")
  
  db_profile = rbind(sp_profile, nl_profile)
  db_feature = cbind(rbind(sp_feature, nl_feature), Type = c(rep("Frag", nrow(sp_feature)), rep("Nloss", nrow(nl_feature))))

  valid = which(apply(db_profile, 1, sum)>0)
  db_profile = db_profile[valid,,drop=FALSE]
  db_feature = db_feature[valid,,drop=FALSE]
  
  ################################
  ### Preprocess query spectrum:##
  ################################
  
  dat = denoise_query_spectrum(query_spectrum, prec_mz, 500, 0.001)
  NP = nrow(dat)
  
  if (NP<3){
    message("The query spectrum must contain at least 3 valid peaks!")
    return(NULL)
  }
  
  ##############################################
  ### Pre-search common fragment/neutral loss###
  ##############################################
  
  db_profile1 = c()
  db_feature1 = c()
  dat1 = c()
  
  for (i in 1:NP){
    
    frags = dat[i,1]
    nls = prec_mz - dat[i,1]
    
    valid = which(abs(frags - db_feature[,2])<=frag_mz_search)
    
    if (length(valid)>0){
      valid = valid[1]
      db_profile1 = rbind(db_profile1, db_profile[valid,,drop=FALSE])
      db_feature1 = rbind(db_feature1, db_feature[valid,,drop=FALSE])
      dat1 = rbind(dat1, dat[i,,drop=FALSE])
    }
  }
  
  if (nrow(db_profile1)==0){return(NULL)}

  # Filter out db samples with fewer than minimum fragment matches:
  
  peak_matches = apply(db_profile1, 2, function(x) sum(x>0))
  valid = which(peak_matches>=min_frag_match)  

  if (length(valid)==0){return(NULL)}
  db_profile1 = db_profile1[,valid,drop = FALSE]
  
  # Filter out empty db features:
  
  feature_matches = apply(db_profile1, 1, function(x) sum(x>0))
  valid = which(feature_matches>0)
  if (length(valid)==0){return(NULL)}
  
  db_profile = db_profile1[valid,,drop = FALSE]
  db_feature = db_feature1[valid,,drop = FALSE]
  dat = dat1[valid,,drop=FALSE]
  NDB = ncol(db_profile)
  
  ###########################
  ### Calculate Similarity###
  ###########################

  if (method == "Matches"){
    temp = apply(db_profile, 2, function(x) sum(x>0))
    sim.scores = cbind.data.frame(ID = names(temp), SCORES = as.numeric(temp))
  }
  
  if (method != "Matches"){
    
    scores = rep(0, NDB)
    
    for (i in 1:NDB){
      
      mz_pairs = cbind(dat[,1], db_feature$Mass)
      intensity_pairs = cbind(dat[,2], db_profile[,i])
      valid = which(intensity_pairs[,2]>0)
      
      mz_pairs = mz_pairs[valid,,drop=FALSE]
      intensity_pairs = intensity_pairs[valid,,drop=FALSE]
      intensity_pairs[,2] = intensity_pairs[,2]/max(intensity_pairs[,2])*100 # Normalize again db spectrum
      
      ff1 = mz_pairs[,1]
      ff2 = mz_pairs[,2]
      int1 = intensity_pairs[,1]
      int2 = intensity_pairs[,2]
      
      if (method == "Cosine"){
        sim =  (int1 %*% int2) / (sqrt(sum(int1^2)) * sqrt(sum(int2^2)))
      }
      
      if (method == "Spearman"){
        sim =  cor(int1, int2, method = "spearman")/2 + 0.5
      }
      
      if (method == "Euclidean"){
        sim = 100/(100+sum(sqrt((int1-int2)^2)))
      }
      
      if (method == "MassBank"){
        W1 = (int1)^0.5*(ff1)^2
        W2 = (int2)^0.5*(ff2)^2
        sim = sum((W1*W2)^2)/(sum(W1^2)*sum(W2^2))
      }
      
      if (method == "NIST"){
        W1 = int1*ff1
        W2 = int2*ff2
        sim = sum((W1*W2)^0.5)/sqrt(sum(W1)*sum(W2))
    }
    scores[i] = sim
  }
    
   sim.scores = cbind.data.frame(ID = colnames(db_profile), SCORES = scores)
 }
  
  ###########################
  ### Filter and output #####
  ###########################
  
  sim.scores = sim.scores[sim.scores$SCORES>0,,drop=FALSE]
  if (nrow(sim.scores)==0){return(NULL)}
  sim.scores = sim.scores[order(sim.scores[,2], decreasing = T),,drop=FALSE]
  
  return(sim.scores)
}

############################
### Internal functions:####
###########################

denoise_query_spectrum<-function(sp, mz0, max_peak, min_relative){
  
  denoised_spectrum = matrix(c(0,0),1,2)
  
  if (nrow(sp)>0){

    # Filter top peaks:
    
    sp = sp[order(sp[,2], decreasing = T),,drop=FALSE]
    tops = min(max_peak, nrow(sp))  
    sp = sp[1:tops,,drop=FALSE]
    
    # Normalize to 100:
    
    sp1 = sp
    sp1[,2] = sp1[,2]/max(sp1[,2])*100
    
    # Relative Intensity filter:
    
    filter = which(sp1[,2]>=min_relative & sp1[,1]<mz0-1)
    sp = sp1
    sp = sp[filter,,drop=FALSE]
    
    # Check validity:
    
    if (nrow(sp)>0){
      sp = sp[order(sp[,1]),,drop=FALSE]
      denoised_spectrum = sp
    }
  }
  return(denoised_spectrum)
}

load_object <- function(file) {
  tmp <- new.env()
  load(file = file, envir = tmp)
  tmp[[ls(tmp)[1]]]
}