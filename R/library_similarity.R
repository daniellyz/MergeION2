#' Searching a query spectrum in a spectral library
#'
#' The function calculates spectral similarity of a query spectrum to an existing spectral library
#'
#' @param query_spectrum  Two-column data matrix. Two columns represent m/z and intensity of query tandem spectrum. At least 3 valid peaks should be provided
#' @param polarity A single character. Either "Positive" or "Negative". Ion mode of the query spectrum.
#' @param prec_mz Numeric. Precursor mass of query spectrum.
#' @param use.prec Boolean. If set to TRUE, precursor mass is used to "pre-query" the library
#' @param input_library A list generated by the function library_generator() or the name of mgf/msp/RData spectral library file
#' @param input_matrix Transformed spectral library by the function library2matrix
#' @param method Character. Similarity metrics
#' \itemize{
#'   \item{Matches:}{ Conting number of fragment or neutral loss matches}
#'   \item{Pearson:}{ Pearson similarity score based on intensity vectors of fragments. Same as dot product since both query and db spectra are normalized to 100.}
#'   \item{Spearman:}{ Spearman similarity based on intensity ranks of fragments.}
#'   \item{MassBank:}{Similarity score used by MassBank using weighted pearson score}
#'   \item{NIST:}{Similarity score used by NIST using weighted pearson score}
#'   
#' }
#' @param prec_mz_search Numeric. Absolute mass tolerance in Da for precursor mass search.
#' @param frag_mz_search Numeric. Absolute mass tolerance in Da for MS/MS peak matching.
#' @param min_frag_match Integer. Minimum matched peaks (or corresponding neutral losses) to make a match	
#' 
#' @return A list of library items (ID and formula) ranked by the spectral similarity score with query spectrum.
#'
#' @author Youzhong Liu, \email{Youzhong.Liu@uantwerpen.be}
#'
#' @examples
#' 
#' # Load database to object lib4:
#' data(Local_DB_RMassBank_Calibrated)
#' 
#' # Load query spectra
#' cocain_file <- list.files(system.file("spectra", package = "MergeION"),".msp", full.names = TRUE)[1]
#' query_spectrum = cocain_file$sp[[1]]
#' 
#' # Search in the spectra library without using precursor mass pre-search
#' scores = library_similarity(query_spectrum, polarity = "Positive", prec_mz = 313.067, use.prec = FALSE, 
#'                          input_library = lib4, input_matrix = NULL, 
#'                          method = "Matches", prec_ppm_search = 10, frag_mz_search = 0.01, min_frag_match = 5)
#' 
#' # Visualize the top candidate
#' library_visualizer(lib4, id = scores$ID[1], query_spectrum) 
#' 
#' @importFrom tools file_ext
#'
#' @export

library_similarity<- function(query_spectrum, polarity = "Positive", prec_mz = 100, use.prec = FALSE, 
                              input_library = NULL, input_matrix = NULL, 
                              method = c("Matches", "Pearson", "Spearman", "MassBank", "NIST"), 
                              prec_ppm_search = 10, frag_mz_search = 0.005, min_frag_match = 6){
  
  options(stringsAsFactors = FALSE)
  options(warn=-1)
  
  if (!is.null(query_spectrum)){if (ncol(query_spectrum)<2){stop("Spectrum must have 2 columns m/z and intensity!")}}
  if (!(polarity %in% c("Positive", "Negative"))){stop("Polarity of query spectrum must be positive or negative")}
#  if (min_frag_match<5){stop("min_frag_match should not be smaller than 5!")}
  
  ##############################
  ### Using New Input Library ##
  ##############################
  
  if (is.null(input_matrix)){
    
    if (is.character(input_library)){
      if (file_ext(input_library)!="mgf" & file_ext(input_library)!="msp" & file_ext(input_library)!="RData"){
      stop("The input library must be mgf, msp or RData format!")
    }}
  
    if (is.character(input_library)){
      if (file_ext(input_library)=="mgf"){
        input_library = readMGF2(input_library)}
      if (file_ext(input_library)=="RData"){
        input_library = load_object(input_library)}
      if (file_ext(input_library)=="msp"){
        input_library = readMSP2(input_library)}
     }
  
    if (!is.null(input_library)){
      if (length(input_library)==2 & "complete" %in% names(input_library)){
        input_library = input_library$complete
      }
      if (length(input_library)!=2 || (!is.list(input_library$sp)) || !is.data.frame(input_library$metadata)){
        stop("Please make sure your input library is a valid output of library_generator()!")
      }
    } else {stop("Please provide input library!")}
  
    input_library = library_manager(input_library, query = paste0("IONMODE=", polarity))$SELECTED
  
    if (use.prec){input_library = library_manager(input_library, query = paste0("PEPMASS=", prec_mz), ppm_search = prec_ppm_search)$SELECTED}
  
    if (nrow(input_library$metadata)==0){return(NULL)}
    
    if (nrow(input_library$metadata)>0){
      input_matrix = library2matrix(input_library, consensus_window = 0.01)
      db_profile = input_matrix$db_profile
      db_feature = input_matrix$db_feature
    }
  
  ###########################################
  ### Using Existing Library (e.g MassBank) #
  ###########################################

  } else {

    input_library = input_matrix$ref_lib
    db_profile = input_matrix$db_profile
    db_feature = input_matrix$db_feature
    
    if (use.prec){
      input_library = library_manager(input_library, query = paste0("PEPMASS=", prec_mz), ppm_search = prec_ppm_search)
      valid = match(as.character(input_library$ID_SELECTED), as.character(input_matrix$ref_lib$metadata$ID))
      if (length(valid)==0){return(NULL)}
      
      input_library = input_library$SELECTED
      db_profile = db_profile[,valid,drop=FALSE]
    }
  }
  
  ################################
  ### Preprocess query spectrum:##
  ################################
  
  dat = denoise_query_spectrum(query_spectrum, prec_mz, 500, 0.001)
  NP = nrow(dat)
  
  if (NP<3){
    message("The query spectrum must contain at least 3 valid peaks!")
    return(NULL)
  }
  
  ##############################################
  ### Pre-search common fragment/neutral loss###
  ##############################################
  
  db_profile1 = c()
  db_feature1 = c()
  dat1 = c()
  
  for (i in 1:NP){
    
    frags = dat[i,1]
    nls = prec_mz - dat[i,1]
    
    valid = which(abs(frags - db_feature[,2])<=frag_mz_search)
    
    if (length(valid)>0){
      valid = valid[1]
      db_profile1 = rbind(db_profile1, db_profile[valid,,drop=FALSE])
      db_feature1 = rbind(db_feature1, db_feature[valid,,drop=FALSE])
      dat1 = rbind(dat1, dat[i,,drop=FALSE])
    }
  }
  
  if (is.null(db_profile1)){return(NULL)}
  
  if (!is.null(db_profile1)){
    if (nrow(db_profile1)==0){
    return(NULL)
  }}
  
  # Filter out db samples with fewer than minimum fragment matches:
  
  peak_matches = apply(db_profile1, 2, function(x) sum(x>0))
  valid = which(peak_matches>=min_frag_match)  

  if (length(valid)==0){return(NULL)}
  db_profile1 = db_profile1[,valid,drop = FALSE]
  
  # Filter out empty db features:
  
  feature_matches = apply(db_profile1, 1, function(x) sum(x>0))
  valid = which(feature_matches>0)
  if (length(valid)==0){return(NULL)}
  
  db_profile = db_profile1[valid,,drop = FALSE]
  db_feature = db_feature1[valid,,drop = FALSE]
  dat = dat1[valid,,drop=FALSE]
  
  NDB = ncol(db_profile)
  
  ###########################
  ### Calculate Similarity###
  ###########################

  # Normalize first the spectra:
  
  dat[,2] = dat[,2]/max(dat[,2])*100 # Normalize
  db_profile <- apply(db_profile, 2, function(x) x/max(x)*100)

  if (method == "Matches"){
    sim = apply(db_profile, 2, function(x) sum(x>0))
  }
  
  if (method == "Dot"){
    sim = cov(dat[,2], db_profile)
    sim = sim/max(sim)
  }
  
  if (method == "Pearson"){
    sim = cor(dat[,2], db_profile, method = "pearson")/2 + 0.5
  }
  
  if (method == "Spearman"){
    sim = cor(dat[,2], db_profile, method = "spearman")/2 + 0.5
  }
  
  if (method == "MassBank"){
    dat_weighted = (db_feature$Mass^2)*(dat[,2]^0.5)
    db_profile_weighted = (db_feature$Mass^2)*(db_profile^0.5)
    sim = cor(dat_weighted, db_profile_weighted, method = "pearson")/2 + 0.5
  }
  
  if (method == "NIST"){
    dat_weighted = db_feature$Mass*dat[,2]
    db_profile_weighted = db_feature$Mass*db_profile
    sim = cor(dat_weighted, db_profile_weighted, method = "pearson")/2 + 0.5
  }
  
  sim = round(as.numeric(sim),2)
  sim.scores = cbind.data.frame(ID = colnames(db_profile), SCORES = sim)

  ########################################
  ### Filter, add formula and output #####
  ########################################
  
  sim.scores = sim.scores[sim.scores$SCORES>0,,drop=FALSE]
  if (nrow(sim.scores)==0){return(NULL)}
  
  if ("FORMULA" %in% colnames(input_matrix$ref_lib$metadata)){
    
    all_formulas = input_matrix$ref_lib$metadata$FORMULA
    valid = match(sim.scores[,1], input_matrix$ref_lib$metadata$ID)
    sim.scores$FORMULA = all_formulas[valid]
  } else {sim.scores$FORMULA = "N/A"}
  
  sim.scores$ID[sim.scores$ID==""] = "N/A"
  sim.scores$FORMULA[sim.scores$FORMULA==""] = "N/A"
  sim.scores = sim.scores[order(sim.scores$SCORES, decreasing = T),]
  
  return(sim.scores)
}

############################
### Internal functions:####
###########################

denoise_query_spectrum<-function(sp, mz0, max_peak, min_relative){
  
  denoised_spectrum = matrix(c(0,0),1,2)
  
  if (nrow(sp)>0){

    # Filter top peaks:
    
    sp = sp[order(sp[,2], decreasing = T),,drop=FALSE]
    tops = min(max_peak, nrow(sp))  
    sp = sp[1:tops,,drop=FALSE]
    
    # Normalize to 100:
    
    sp1 = sp
    sp1[,2] = sp1[,2]/max(sp1[,2])*100
    
    # Relative Intensity filter:
    
    filter = which(sp1[,2]>=min_relative & sp1[,1]<mz0-1)
    sp = sp1
    sp = sp[filter,,drop=FALSE]
    
    # Check validity:
    
    if (nrow(sp)>0){
      sp = sp[order(sp[,1]),,drop=FALSE]
      denoised_spectrum = sp
    }
  }
  return(denoised_spectrum)
}

load_object <- function(file) {
  tmp <- new.env()
  load(file = file, envir = tmp)
  tmp[[ls(tmp)[1]]]
}