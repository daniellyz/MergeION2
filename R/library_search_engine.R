#' Matching query spectrum to existing library
#'
#' The function searches unknown MS/MS spectra in a spectral library
#'
#' @param library_type A character precising the type of library. Fast search: "Private" for precompiled JANSSEN library (2019-9-20); "Public" for drug spectra in public domains (GNPS and MASSBANK, positive mode only); Slower search: "Local" if a customized spectra library is provided
#' @param local_library Customized spectral library. Obligatory if library_type = "Local". A list generated by the function library_generator() or the name of mgf spectral library file
#' @param ion.mode Character indicating whether the query spectrum is in Positive or Negative mode
#' @param query_spectrum  Two-column data matrix. Two columns represent m/z and intensity of query tandem spectrum. At least 3 valid peaks should be provided
#' @param method Character. Method to compare the similarity between query spectrum and library spectra.
#' \itemize{
#'   \item{Fragment:}{ Counting only number of fragment matches}
#'   \item{Simple:}{ Conting number of fragment and neutral loss matches}
#'   \item{Cosine:}{ Cosine similarity score from OrgMassSpecR package.}
#' }
#' @param prec_mz Numeric. Precursor mass of query spectrum (if known). Default value is 0. Must NOT be 0 if method = "All" or use.prec = TRUE (see below)
#' @param use.prec Boolean. If set to TRUE, precursor mass (if known) is used to "pre-query" the library
#' @param ppm_search Numeric. Mass tolerance in ppm for precursor search.
#' @param tops Integer. Number of top compound candidates kept in the output mgf file
#' @param max_peaks Integer. Top most intense peaks kept in the query spectrum
#' @param min_relative Numeric between 0.1 and 1. Minimum relative intensity of peaks to not be considered as noise in the query spectrum
#' @param mirror.plot Boolean. True if the query-library comparison is visualized as mirror plot
#' @param png.out Boolean. True if plotted mirror spectra are exported as png images!
#'
#' @return
#' \itemize{
#'    \item{<plot>:}{ Comparing query spectrum to ordered "hits" in the spectrum library}
#'    \item{SELECTED:}{ Library object that contain found scans.}
#'    \item{ID_SELECTED:}{ IDs of found compounds.}
#'    \item{SCORES:}{ Similarity scores between query spectrum and each }
#' }
#'
#' @author Youzhong Liu, \email{Youzhong.Liu@uantwerpen.be}
#'
#' @examples
#' 
#' dat = cbind(c(136.073,149.071,151.0991,180.047),c(1,1,20,3))
#' 
#' # Local search:
#' data(DRUG_THERMO_LIBRARY) # Load library2
#' query = library_search_engine(library_type = "Local", local_library = library2, 
#' query_spectrum = dat, method = "Cosine", prec_mz = 0, use.prec =FALSE, mirror.plot = F)
#'
#' # Search in public database:
#' query = library_search_engine(library_type = "Public", local_library = NULL, 
#' query_spectrum = dat, method = "Simple", prec_mz = 346.122, use.prec =FALSE, mirror.plot = F)
#'
#' # Query-library comparison via mirror plot:
#' library_visualizer_similarity(query$SELECTED, id= query$ID_SELECTED[1], query_spectrum = dat)
#'
#' @importFrom MSnbase fData readMgfData
#' @importFrom tools file_ext
#' @importFrom stringr str_replace_all fixed
#' @importFrom OrgMassSpecR SpectrumSimilarity
#'
#' @export

library_search_engine <- function(library_type = c("Private", "Public", "Local"), local_library = NULL, 
                         query_spectrum=NULL, ion.mode = c("Positive", "Negative"), 
                         method = c("Fragment", "Simple", "Cosine"),
                         prec_mz = 0, use.prec = FALSE, ppm_search = 10, 
                         tops = 5, max_peaks = 200, min_relative = 0.1,
                         mirror.plot = T, png.out=F){
  
  options(stringsAsFactors = FALSE)
  options(warn=-1)
  SELECTED_LIBRARY = NULL
  sim_scores = NULL # Similarity score per each element in the library
  
  #################
  ### Check inputs:
  #################
  
  if (!is.character(library_type)){
    stop("Library type must be a character!")
  }
  
  if (!(library_type %in% c("Private", "Public", "Local"))){
    stop("Library type must be Private, Public or Local!")
  }
 
  if (library_type == "Public" && ion.mode == "Negative"){
    stop("Sorry! Public library search is now only developped for positive ion mode spectra!")
  } 
  
  if ((library_type=="Local") && is.null(local_library)){
    stop("Please provide the local library!")
  }
  
  if ((library_type=="Local") && is.character(local_library)){
    if (file_ext(library)!="mgf"){
      stop("The file extension of your input library must be mgf!")
  }}
  
  if (is.list(local_library)){
    if (length(local_library)==2 && "complete" %in% names(library)){
      local_library = local_library$complete
    }
    if (length(local_library)!=2 || (!is.list(local_library$sp)) || !is.data.frame(local_library$metadata)){
      stop("Please make sure your input library is a valid output of library_generator()!")
    }
  }
  
  if (library_type=="Local"){
    local_library = library_manager(local_library, query = "MSLEVEL = 1")$LEFT
    local_library = library_manager(local_library, query = paste0("IONMODE = ",ion.mode[1]))$SELECTED
    if (nrow(local_library$metadata)==0){stop("No MS/MS records!")}
    if (nrow(local_library$metadata)>50){
      print("Attention! Spectral search can be slow if a large local library is provided!")
    }
  }
  
  if (is.null(query_spectrum)){
    stop("Please provide a 2 column query spectrum!")
  } else {
    if (ncol(query_spectrum)<2){
      stop("Query spectrum must have at least 2 columns: m/z and intensity!")
    }
    if (nrow(query_spectrum)<3){
      stop("Query spectrum must have at least 3 peaks!")
    }
  }
  
  if ((prec_mz == 0) && use.prec){
    stop("Please provide the precursor mass if it is used for library search!")
  }

  if ((prec_mz == 0) && (method == "Simple")){
    stop("Please provide the precursor mass if neutral loss are considered!")
  }
  
  ##################
  ### Load database:
  ##################
  
  if (library_type=="Private"){
    data(JANSSEN_2019_09)
    if (ion.mode =="Positive"){
      library = list(metadata = positive_metadata, sp = positive_sp_list)
      api_profile = positive_profile
      api_feature = positive_profile_feature
    }
    if (ion.mode =="Negative"){
      library = list(metadata = negative_metadata, sp = negative_sp_list)
      api_profile = negative_profile
      api_feature = negative_profile_feature
    }
  }
  
  if (library_type=="Public"){
    data(DRUG_PLUS)
    library = library1
    library$metadata$SCANS = 1:nrow(library$metadata)
    api_feature = api_profile_feature
  }
  
  if (library_type=="Local"){
    library = local_library
  }
  
  # Select precursor mass:
  
  if (prec_mz!=0 && use.prec){
    query = paste0("PEPMASS = ", prec_mz)
    library = library_manager(library, query = query, ppm_search = ppm_search)
    library = library$SELECTED # Filter library according to precursor mass
    if (nrow(library$metadata)==0){stop("No record with specified precursor mass found!")}
  }
  
  api_profile = api_profile[,which(colnames(api_profile) %in% library$metadata$ID),drop=FALSE] # Filter api_profile
  
  metadata = library$metadata
  spectrum_list = library$sp
  
  ###############################
  ### Preprocess query spectrum:
  ###############################
  
  dat = query_spectrum[,1:2, drop = FALSE]
  XP = nrow(dat)
  
  # Top peaks, normalize, cut only masses smaller than precursor and filter background noise:
  
  dat = dat[order(dat[,2], decreasing = T),] # Filter>0.1
  dat = dat[1:min(max_peaks, XP),]
  dat[,2] = dat[,2]/max(dat[,2])*100
  dat = dat[dat[,2]>min_relative,,drop = FALSE]
  dat = dat[order(dat[,1]),] # Filter>0.1
  
  if (prec_mz==0){prec_mz = 10000} # Not consider the precursor mass
  dat = dat[dat[,1]<prec_mz - 0.5,]

  if (nrow(dat)<3){
    stop("The query spectrum must contain at least 3 valid peaks!")
  }
  
  frags = dat[,1]
  nls = prec_mz - frags
  nls = nls[nls>0.5] # Must higher than 0.5
  
  ###################
  ### Local search###
  ###################
  
  if (library_type=="Local"){
    
    NS = nrow(metadata)
    sim_scores = rep(0, NS) # Similarity score per each element in the library
    
    nloss_list = lapply(1:NS, function(i) as.numeric(metadata$PEPMASS[i])-spectrum_list[[i]][,1])

    for (i in 1:NS){
      if (method == "Fragment"){
        dist_spec = sapply(spectrum_list[[i]][,1], ppm_distance12, frags)
        temp = which(dist_spec<0.005, arr.ind = T)
        score = length(unique(temp[,2]))
        sim_scores[i] = score
      }
    
      if (method == "Simple"){
        dist_spec = sapply(spectrum_list[[i]][,1], ppm_distance12, frags)
        temp = which(dist_spec<0.005, arr.ind = T)
        score1 = length(unique(temp[,2]))
        dist_loss = sapply(nloss_list[[i]], ppm_distance12, nls)
        temp = which(dist_loss<0.005, arr.ind = T)
        score2= length(unique(temp[,2]))
        sim_scores[i] = score1 + score2
    }
    
    if (method == "Cosine"){
      abs_search = ppm_search/1000000*median(frags) # Da window for cosine spectra search
      sim_scores[i] = SpectrumSimilarity(dat, spectrum_list[[i]], t = abs_search)
      graphics.off()
    }
    }
  }
    
  ###################
  ### Fast search####
  ###################
    
  if (library_type!="Local"){
    
    frag_feature = api_feature[api_feature$Feature == "Fragment",]
    nloss_feature = api_feature[api_feature$Feature == "Nloss",]
    
    # Match ID:
    
    id_matched = c()
    
    for (frag in frags){
      error = abs(frag_feature$Mass - frag)
      if (min(error)<0.005){
        id_matched = c(id_matched, frag_feature$ID[which.min(error)])
    }}
    
    if (method == "Simple"){ # If neutral loss is considered
      for (nl in nls){
        error = abs(nloss_feature$Mass - nl)
        if (min(error)<0.005){
          id_matched = c(id_matched, nloss_feature$ID[which.min(error)])
      }}}
    
    # Count:
    
    matched = matrix(0, nrow(api_feature),1)
    matched[which(api_feature$ID %in% id_matched),1]= 1 # Create binary vector
    sim_scores = data.matrix(t(matched)) %*% data.matrix(api_profile)
    sim_scores = as.numeric(sim_scores)
  }
  
  ###########################
  ### Plot and output results:
  ###########################
  
  # Top scores and output:
  
  indexes = order(sim_scores,decreasing=T)
  indexes = intersect(indexes,which(sim_scores>0))
  NI = length(indexes)
  
  if (NI>0){
   
    indexes = indexes[1:min(NI, tops)]
    
    SELECTED_LIBRARY = list()
    SELECTED_LIBRARY$sp = library$sp[indexes]
    SELECTED_LIBRARY$metadata = library$metadata[indexes,]
    sim_scores = sim_scores[indexes]
    
    # Plot:
    if (mirror.plot){
      for (i in 1:length(indexes)){
        if (png.out){
          png(paste0("SIM_SCAN_", SELECTED_LIBRARY$metadata$SCANS[i],".png"), width = 700, height = 480)
        }
        bottom.label = paste0("Library spectrum of ID = ", SELECTED_LIBRARY$metadata$ID[i])
        xlim = c(min(dat[,1])*0.8, max(dat[,1])*1.2)
        SpectrumSimilarity(dat, SELECTED_LIBRARY$sp[[i]], top.label="Query spectrum",bottom.label= bottom.label,xlim=xlim, print.graphic = T)
        
        if (png.out){dev.off()}
      }
    }
  }
  
  return(list(SELECTED = SELECTED_LIBRARY,
              ID_SELECTED = unique(SELECTED_LIBRARY$metadata$ID),
              SCORES = sim_scores))
}

############################
### Internal functions:####
###########################

ppm_distance12<-function(x,y){
  return(abs(x-y))
}
