#' Extracting or generating representative scans for each compound and create a new library
#'
#' The function generates a consensus scan for each compound ID in the spectral library.
#'
#' @param input_library A list generated by the function library_generator() or the name of mgf spectral library file
#' @param method  A character of method for grouping library by compound IDs.
#' \itemize{
#'   \item{consensus:}{ Consensus spectra were generated by merging spectra of the same compound ID. All peaks were kept, similar peaks were aligned.}
#'   \item{common_peaks:}{ Consensus spectra were generated by merging spectra (MS1 and MS2) of the same compound ID. Peaks detected in all spectra were kept and averaged.}
#'   \item{max_tic:}{ For the same compound ID, the spectrum with higher TIC was extracted and kept.}
#'   \item{most_recent:}{ For the same compound ID, the most recent record was kept.}
#' }
#' @param consensus_window m/z window (in Dalton) for spectra alignment, only used when method = "consensus" or "common_peaks". To generate consensus spectra, mass peaks in different spectra within the mass window were aligned by averaging their mass values and intensities. The metadata was kept for the spectrum with higher TIC.
#' @param params.ms.preprocessing Paremters for post-processing merged scan. It must contain:
#' \itemize{
#'  \item{relative:}{ Numeric between 0 and 100. Relative intensity threshold of the highest peak in each spectrum.}
#'  \item{max_peaks:}{ Integer higher than 3. Maximum number of peaks kept per spectrum from the highest peak.}
#' }
#'
#' @return The same as library_generator()
#'
#' @author Youzhong Liu, \email{YLiu186@ITS.JNJ.com}
#'
#' @examples
#'
#' data(DRUG_THERMO_LIBRARY)
#'
#' # Withholding the scan (MS1 and MS) with highest TIC for each ID:
#'
#' library2_1 = library_merger(library2, method="max_tic")
#'
#' # Generating consensus spectra for all scans (MS1 and MS) of the same ID. The scan with highest TIC is used for metadata:
#'
#' library2_2 = library_merger(library2, method="common_peaks", consensus_window = 0.005)
#'
#' @export
#'
#' @importFrom tools file_ext
#' 
library_merger<-function(input_library, method = c("most_recent", "max_tic", "consensus", "common_peaks"), consensus_window = 0.01,
                         params.ms.preprocessing = list(relative =0.01, max_peaks = 200)){

  options(stringsAsFactors = FALSE)
  options(warn=-1)

  ####################################
  ### Read and check input library:###
  ####################################
  
  if (is.character(input_library)){
    if (input_library!=""){
      if (file_ext(input_library)!="mgf" & file_ext(input_library)!="RData"){
        stop("The input library must be mgf or RData format!")}
    }
  }
  
  if (is.character(input_library)){
    if (file_ext(input_library)=="mgf"){
      input_library = readMGF2(input_library)}
    if (file_ext(input_library)=="RData"){
      input_library = load_object(input_library)}
  }
  
  if (!is.null(input_library)){
    if (length(input_library)==2 & "complete" %in% names(input_library)){
      input_library = input_library$complete
    }
    if (length(input_library)!=2 || (!is.list(input_library$sp)) || !is.data.frame(input_library$metadata)){
      stop("Please make sure your input library is a valid output of library_generator()!")
    }
    spectrum_list=input_library$sp
    metadata=input_library$metadata
  }
  
  if (!(method  %in% c("consensus","common_peaks","max_tic","most_recent"))){
    stop("The library processing method does not exist!")
   }

  ###############
  ### Grouping:##
  ###############
  
  labels = paste(metadata$IONMODE, metadata$MSLEVEL, sep="-")
  groups = unique(labels)
  
  #################
  ### Initialize:##
  #################
  
  new_spectrum_list = list()
  new_meta_data = c()
  NN = 0
  
  #############################
  ### Combine scan per group:##
  #############################

  for (gg in groups){
    
    index1 = which(labels==gg)
    
    metadata1= metadata[index1,,drop=FALSE]
    spectrum_list1 = spectrum_list[index1]
    ID_list1=unique(metadata1$ID)

    for (ID in ID_list1){

      selected_rows = which(metadata1$ID==ID)
      NSR = length(selected_rows)
      
      sub_metadata = metadata1[selected_rows,,drop=FALSE]
      sub_spectrum_list = spectrum_list1[selected_rows]
      
      # Representative scans in the library:

      if (method=="most_recent"){
        wm = which.max(as.numeric(sub_metadata$SCANS))
      } else {
        wm = which.max(sub_metadata$TIC)
      }

      new_meta_data = rbind.data.frame(new_meta_data,sub_metadata[wm,,drop=FALSE]) # Update metadata
      NN = NN+1

      # Append spectra list if no need for spectra merge
      
      if (method %in% c("max_tic", "most_recent") || NSR==1){
        new_spectrum_list[[NN]]=sub_spectrum_list[[wm]]
      }
      
      # Append consensus spectrum:
      
      if (method %in% c("consensus", "common_peaks") && NSR>1){
          output_consensus = average_spectrum(sub_spectrum_list, consensus_window)
          temp_spectrum = output_consensus$new_spectrum
          
          if (method == "common_peaks"){
            temp_zeros =  apply(output_consensus$I_matrix, 1, function(x) sum(x==0))
            temp_spectrum = temp_spectrum[temp_zeros==0,,drop=FALSE]
          }
          new_spectrum_list[[NN]] = temp_spectrum
      }
    }
  }

  #############################
  ### Denoising and Filtering:#
  #############################
  
  new_spectrum_list1 = list()
  included=c()
  n0=0
  
  for (i in 1:NN){
    
    sp0 = new_spectrum_list[[i]]
    sp1 = denoise_spectrum(sp0, params.ms.preprocessing$max_peaks, params.ms.preprocessing$relative)
    
    if (nrow(sp1)>1){
      included = c(included, i)
      n0 = n0 + 1
      new_spectrum_list1[[n0]]=sp1
    }
  }
  
  new_meta_data = new_meta_data[included,,drop=FALSE]
  
  ####################
  ### Return results:
  ####################

  output_library = list()
  output_library$sp = new_spectrum_list1
  output_library$metadata = cbind.data.frame(new_meta_data, PARAM_CONSENSUS = method)

  return(output_library)
}


######################
### Internal function:
######################

load_object <- function(file) {
  tmp <- new.env()
  load(file = file, envir = tmp)
  tmp[[ls(tmp)[1]]]
}

# Keep top peaks and noramalzie

denoise_spectrum<-function(sp, max_peak, min_relative){
  
  denoised_spectrum = matrix(c(0,0),1,2)
  
  if (nrow(sp)>0){
    
    # Filter top peaks:
    
    sp = sp[order(sp[,2], decreasing = T),,drop=FALSE]
    tops = min(max_peak, nrow(sp))  
    sp = sp[1:tops,,drop=FALSE]
    
    # Normalize to 100:
    
    sp1 = sp
    sp1[,2] = sp1[,2]/max(sp1[,2])*100
    
    # Relative Intensity filter:
    
    filter = which(sp1[,2]>=min_relative)
    sp = sp1  
    sp = sp[filter,,drop=FALSE]
    
    # Check validity:
    
    if (nrow(sp)>=2){
      sp = sp[order(sp[,1]),]
      denoised_spectrum = sp
    }
  }
  return(denoised_spectrum)
}

