#' Matching query spectrum to existing library
#'
#' The function searches unknown MS/MS spectra in a spectral library
#'
#' @param library A list generated by the function library_generator() or the name of mgf spectral library file
#' @param ppm_search Numeric. Mass tolerance in ppm for precursor/fragment search.
#' @param tops Integer. Top recommended substructures in the output mgf file
#' @param output String. File name of output library.
#'
#' @return
#' \itemize{
#'    \item{rules_extracted:}{ Matched rule list}
#'    \item{sub_extracted:}{ Library object that contain found scans.}
#'    \item{MGF FILE:}{ A MGF file with annotated substructures will be written in user's folder.}
#' }
#'
#' @author Youzhong Liu, \email{Youzhong.Liu@uantwerpen.be}
#'
#' @examples
#'
#' data(DRUG_THERMO_LIBRARY)
#' results = library_messar(library2, ppm_search = 20, tops = 5, output = "library2_messar.mgf")
#'
#' @importFrom MSnbase fData readMgfData
#' @importFrom tools file_ext
#' @importFrom stringr str_replace_all fixed
#'
#' @export

library_messar<-function(library, ppm_search = 10, tops = 3, metrics = "PRECISION", output="library_messar.mgf"){

  options(stringsAsFactors = FALSE)
  options(warn=-1)
  data(SUBSTRUCTURE_DB)

  #################
  ### Check inputs:
  #################

  if (missing(library)){
    stop("Please provide the output of library_generator() or a .mgf file as input library!")}

  if (is.character(library)){
    if (file_ext(library)!="mgf"){
      stop("The file extension of your input library must be mgf!")
    }}

  if (is.list(library)){
    if (length(library)==2 & "complete" %in% names(library)){
      library = library$complete
    }
    if (length(library)!=2 || (!is.list(library$sp)) || !is.data.frame(library$metadata)){
      stop("Please make sure your input library is a valid output of library_generator()!")
    }}

  library = library_manager(library, query = "MSLEVEL = 1")

  if (nrow(library$LEFT$metadata)==0){stop("No MS/MS records!")}

  ###########################
  ##### MESSAR parameters####
  ###########################

  test_data = library$LEFT
  new_metadata = test_data$metadata
  N = nrow(new_metadata)

  ################
  ##### MESSAR####
  ################

  rules_extracted_list = vector("list", N)
  sub_extracted_list =  vector("list", N)
  estimation_list = rep("N/A", N) # to add into new metadata

  for (i in 1:N){

    print(i)
    masslist = test_data$sp[[i]][,1]
    intlist = test_data$sp[[i]][,2]
    prec_mz = as.numeric(test_data$metadata$PEPMASS[i])

    # Add precursor if not there

    valid1 = which(masslist<(prec_mz+1))
    masslist = masslist[valid1]
    ppm_prec = min(ppm_distance(masslist, prec_mz))

    if (ppm_prec > ppm_search){
      masslist= c(masslist, prec_mz) # Add precursor peak by exact mass
    }

    # Calculate mass diff

    massdiff0 = unique(as.numeric(dist(masslist)))
    massdiff = massdiff0[massdiff0>=30]

    # Search

    selected_index = search_rules(rules_feature, rules_type, masslist, massdiff, ppm_search)

    NRM = length(selected_index)

    if (NRM>0){

      rules_extracted = rules[selected_index,]
      rules_extracted_list[[i]] = rules_extracted # backup

      if (NRM>1){estimation = aggregate_rules_simple(rules_extracted)$sum_aggregated}
      if (NRM==1){estimation = rules_extracted}

      estimation = estimation[order(estimation[,metrics], decreasing=T),]
      estimation = estimation[,c("SUBSTRUCTURE",metrics)]
      colnames(estimation) = c("SUBSTRUCTURE","SCORES")

      sub_extracted_list[[i]] = estimation

      NS = min(nrow(estimation), tops)
      substructure_estimated = estimation$SUBSTRUCTURE[1:NS]
      substructure_estimated = paste0(substructure_estimated, collapse = "||")
      estimation_list[i] = substructure_estimated
    }
  }

  ##############
  #####Output###
  ##############

  test_data$metadata = cbind.data.frame(new_metadata, OUTPUT_MESSAR = estimation_list)
  writeMGF2(test_data, con = output)
  return(list(library_annotated = test_data, rules_extracted =  rules_extracted_list, sub_extracted = sub_extracted_list))
}

###########################
### Internal functions:####
###########################

ppm_distance<-function(x,y){
  return(abs((x-y)/y*1000000))
}


search_rules<-function(ref_feature, ref_feature_type, mass, mass_diff, ppm_search){

  # Combine masses:

  test_feature = c(mass, mass_diff)
  test_feature_type = c(rep('mass', length(mass)), rep("mass_diff", length(mass_diff)))
  NF = length(ref_feature)

  # Search ref features:

  matched_feature = c()
  for (i in 1:NF){

    valid = 1
    feature = ref_feature[[i]]
    feature_type = ref_feature_type[[i]]

    for (f in 1:length(feature)){
      errors = abs((feature[f]-test_feature)/feature[f])*1000000
      min_error = min(errors)
      index_error = which.min(errors)

      if ((min_error <= ppm_search) & (test_feature_type[index_error] == feature_type[f])){
      } else {
        valid = 0
        break
      }
    }
    if (valid == 1){ # If always valid
      matched_feature = c(matched_feature, i)
    }
  }
  return(matched_feature)
}


aggregate_rules_simple <- function(rules_extracted){

  # Group rules by their substructure

  combined_type = aggregate(rules_extracted$SPECTRAL_FEATURE_TYPE, list(rules_extracted$SUBSTRUCTURE), toString)[,2]
  combined_features = aggregate(rules_extracted$SPECTRAL_FEATURE, list(rules_extracted$SUBSTRUCTURE), toString)[,2]
  combined_type = sapply(combined_type, clean_feature_text)
  combined_features = sapply(combined_features, clean_feature_text)

  sum_precision = aggregate(rules_extracted$PRECISION, list(rules_extracted$SUBSTRUCTURE), sum)
  sum_f1 = aggregate(rules_extracted$F1, list(rules_extracted$SUBSTRUCTURE), sum)[,2]
  sum_sensitivity = aggregate(rules_extracted$SENSITIVITY, list(rules_extracted$SUBSTRUCTURE), sum)[,2]
  sum_aggregated = cbind.data.frame(sum_precision, sum_f1, sum_sensitivity)
  colnames(sum_aggregated) = c("SUBSTRUCTURE", "PRECISION", "F1", "SENSITIVITY")

  median_precision = aggregate(rules_extracted$PRECISION, list(rules_extracted$SUBSTRUCTURE), median)
  median_f1 = aggregate(rules_extracted$F1, list(rules_extracted$SUBSTRUCTURE), median)[,2]
  median_sensitivity = aggregate(rules_extracted$SENSITIVITY, list(rules_extracted$SUBSTRUCTURE), median)[,2]
  median_aggregated = cbind.data.frame(median_precision, median_f1, median_sensitivity)
  colnames(median_aggregated) = c("SUBSTRUCTURE", "PRECISION", "F1", "SENSITIVITY")

  max_precision = aggregate(rules_extracted$PRECISION, list(rules_extracted$SUBSTRUCTURE), max)
  max_f1 = aggregate(rules_extracted$F1, list(rules_extracted$SUBSTRUCTURE), max)[,2]
  max_sensitivity = aggregate(rules_extracted$SENSITIVITY, list(rules_extracted$SUBSTRUCTURE), max)[,2]
  max_aggregated = cbind.data.frame(max_precision, max_f1, max_sensitivity)
  colnames(max_aggregated) = c("SUBSTRUCTURE", "PRECISION", "F1", "SENSITIVITY")

  return(list(type=combined_type, features=combined_features,
              sum_aggregated=sum_aggregated, median_aggregated=median_aggregated, max_aggregated=max_aggregated))
}

clean_feature_text <- function(feature){
  feature = str_replace_all(feature, "\\[", "")
  feature = str_replace_all(feature, " ", "")
  feature = str_replace_all(feature, "\\]", "")
  feature = str_replace_all(feature, "\\'","")
  return(feature)
}


