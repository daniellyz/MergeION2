#' Create feature-based molecular networks
#'
#' Generate feature-based molecular networks from raw LC-MS/MS file or spectral summary file, automatically annotate features in a spectral library
#'
#' @param raw_data_file Character. The LC-MS/MS file in mzML/mzXML format or MS/MS spectral summary file in mgf format. Check following link for more information about MS/MS spectral summary file: https://ccms-ucsd.github.io/GNPSDocumentation/featurebasedmolecularnetworking-with-mzmine2/
#' @param feature_table Character. The feature quantification table file. The file should be tab, comma or semi-colon separated txt, dat or csv format. It should contain at least 3 columns: LC-MS feature ID, m/z and RT that could be detected in the raw data file. It can also contain abundance of these features in samples. Check following link for more details about the format: https://ccms-ucsd.github.io/GNPSDocumentation/featurebasedmolecularnetworking-with-mzmine2/
#' @param input_library A list generated by the function library_generator() or the name of mgf/msp/RData spectral library file.
#' @param input_matrix Transformed spectral library by the function library2matrix. Used for MassBank or GNPS spectra library search. Please set to NULL otherwise
#' @param polarity character. Either "Positive" or "Negative". Ion mode of the LC-MS/MS file. 
#' @param params.screening Parameters for feature screening and MS2 spectra pre-processing from raw_data_file:
#' \itemize{
#'  \item{baseline:}{ Numeric. Absolute intensity threshold that is considered as a mass peak and written into the library.}
#'  \item{relative:}{ Numeric between 0 and 100. Relative intensity threshold of the highest peak in each spectrum, peaks above both absolute and relative thresholds are saved in the library.}
#'  \item{max_peaks:}{ Integer higher than 3. Maximum number of peaks kept per spectrum from the highest peak.}
#' }
#' @param params.search List of parameters for feature screening, combining precursor ions and fragments in the input file, as well as for searching in the spectral library. The list must contain following elements:
#' \itemize{
#'  \item{mz_search:}{ Numeric. Absolute mass tolerance in Da.}
#'  \item{ppm_search:}{ Numeric. Absolute mass tolerance in ppm.} 
#'  \item{rt_search:}{ Numeric. Absolute retention time tolerance in second.}
#' }
#' @param params.similarity Parameters for MS/MS spectral similarity determination, used for both molecular networking and spectral library search.
#' \itemize{
#'  \item{method:}{ Characeter.Similarity metrics for networking and spectral library search. Must be "Matches", "Pearson", "Spearman", "MassBank", "NIST". Please check function library_similarity for more details.}
#'  \item{min.frag.match:}{ Integer. Minimum number of common fragment ions (or neutral losses) that are shared to be considered for spectral similarity evaluation. We suggest setting this value to at least 6 for statistical meaningfulness.
#'  \item{min.score:}{ Numeric between 0 and 1. Minimum similarity score to annotate an unknown feature with spectral library or to connect two unknown features because they are similar. It does NOT affect method = "Matches".}
#'  \item{topK:}{ Integer higher than 0. For networking, the edge between two nodes are kept only if both nodes are within each other's TopK most similar nodes. For example, if this value is set at 20, then a single node may be connected to up to 20 other nodes. Keeping this value low makes very large networks (many nodes) much easier to visualize. We suggest keeping this value at 10.}
#' }
#'@param params.network Parameters for post-filtering and annotation of network edges: based on feature correlation (if feature quantification table is provided) and mass difference
#' \itemize{
#'  \item{method:}{ Characeter. Correlation metrics. Must be "pearson" or "spearman".}
#'  \item{min.abs.cor:}{Numeric between 0 and 1. Minimum absolute correlation for kept edges.}
#'  \item{use.reaction:}{ Boolean. TRUE if keep only edges whose mass difference can be annotated to known biochemical reactions.}
#' }
#' 
#' @importFrom tools file_path_sans_ext
#' 
#' @export
#'

network_generator<-function(raw_data_file, feature_table = NULL, input_library = NULL, input_matrix = NULL, polarity = c("Positive", "Negative"),
                  params.screening = list(baseline = 1000, relative = 0.01, max_peaks = 200),
                  params.search = list(mz_search = 0.005, ppm_search = 10, rt_search = 15),
                  params.similarity = list(method = "Pearson", min.frag.match = 6, min.score = 0.6, topK = 10),
                  params.network = list(method = "spearman", min.abs.cor = 0.4, use.reaction = TRUE)){
  
  options(stringsAsFactors = FALSE)
  options(warn=-1)

  baseline = params.screening$baseline
  relative = params.screening$relative
  max_peaks = params.screening$max_peaks 
  
  mz_search = params.search$mz_search
  ppm_search = params.search$ppm_search
  rt_search = params.search$rt_search
  
  sim.method = params.similarity$method
  min.frag.match =  params.similarity$min.frag.match
  min.score = params.similarity$min.score
  topK = params.similarity$topK
  
  cor.method = params.network$method
  min.abs.cor = params.network$min.abs.cor
  use.reaction = params.network$use.reaction
  
  ####################################
  ### Read/Load or screen features ###
  ####################################

  if (!file_ext(raw_data_file) %in% c("mzML", "mzXML", "mgf")){
    stop("The LC-MS/MS file for network generation must be in mgf, mzML or mzXML format!")
  }
                    
  if (file_ext(raw_data_file)=="mgf"){
    ms2dat = readMGF2(raw_data_file)}
  if (file_ext(raw_data_file)=="mzML" || file_ext(raw_data_file)=="mzXML"){
    ms2dat = readMZXML2(raw_data_file, polarity, ppm_search, rt_search, baseline)}
                    
  if (is.null(ms2dat$metadata)){stop("No feature is detected in raw_data_file!")}
  if (nrow(ms2dat$metadata)==0){stop("No feature is detected in raw_data_file!")}
         
  if (is.character(feature_table)){ 
    if (!file_ext(feature_table) %in% c("csv", "dat", "txt")){
      stop("The feature table must be in csv, dat and txt file!")
    }

    FT = read.csv(feature_table,sep=";",dec=".",header=T)
    if (ncol(FT)==1){FT = read.csv(feature_table,sep=",",dec=".",header=T)}  
    if (ncol(FT)==1){FT = read.csv(feature_table,sep="\t",dec=".",header=T)}  
    if (ncol(FT)<3){stop("Input feature quantification format not valid!")}
    
    FT_features = FT[,1:3] 
    colnames(FT_features)[1:3] = c("ID", "Mass", "RT")
    FT_features = apply(FT_features, 2, as.numeric)
    FT_features = data.frame(FT_features)
    
    if (ncol(FT)>8){
      FT_profile = FT[,4:ncol(FT)]
      FT_profile = apply(FT_profile, 2, as.numeric)
      FT_profile = data.matrix(FT_profile)
    } else {FT_profile = NULL}
  } else {
    FT_features = NULL
    FT_profile = NULL
  }
  
  if (is.null(input_matrix) & !is.null(input_library)){
    
    if (is.character(input_library)){
      if (file_ext(input_library)!="mgf" & file_ext(input_library)!="msp" & file_ext(input_library)!="RData"){
        stop("The input library must be mgf, msp or RData format!")
      }
    }
  
    if (is.character(input_library)){
      if (file_ext(input_library)=="mgf"){
        input_library = readMGF2(input_library)}
      if (file_ext(input_library)=="RData"){
        input_library = load_object(input_library)}
      if (file_ext(input_library)=="msp"){
        input_library = readMSP2(input_library)}
    }
  
    if (!is.null(input_library)){
      if (length(input_library)==2 & "complete" %in% names(input_library)){
        input_library = input_library$complete
      }
      if (length(input_library)!=2 || (!is.list(input_library$sp)) || !is.data.frame(input_library$metadata)){
        stop("Please make sure your input library is a valid output of library_generator()!")
      }
    }
    input_matrix = library2matrix(input_library, consensus_window = mz_search*2)
  } 
  
  if (!(polarity %in% c("Positive", "Negative"))){
    stop("Polarity must be either Positive or Negative")
  }
  
  #####################
  ### Filter ms2dat ###
  #####################

  # MSLEVEL and IONMODE filtering:
  
  if (!("MSLEVEL" %in% colnames(ms2dat$metadata))){ms2dat$metadata$MSLEVEL=2}
  if (!("IONMODE" %in% colnames(ms2dat$metadata))){ms2dat$metadata$IONMODE=polarity}
  if ("FEATURE_ID" %in% colnames(ms2dat$metadata)){ms2dat$metadata$ID=ms2dat$metadata$FEATURE_ID}        
  ms2dat$metadata$SCANS = 1:nrow(ms2dat$metadata)
  
  ms2dat = library_manager(ms2dat, query= c("MSLEVEL=2", paste0("IONMODE=",polarity)), logical = "AND")$SELECTED 
  
  # Match to feature table:
  
  if (!is.null(FT_features)){
    MDD = nrow(ms2dat$metadata)
    ms2_metadata_selected = c()
    ms2_profile_selected = c()
    ms2_profile_id_selected = c()
    ms2_sp_selected = list()
    kkk = 0
    
    for (jj in 1:MDD){
      ms_error = abs(as.numeric(ms2dat$metadata$PEPMASS[jj]) - FT_features$Mass)
      ppm_error = ppm_distance(FT_features$Mass, as.numeric(ms2dat$metadata$PEPMASS[jj]))
      rt_error = abs(as.numeric(ms2dat$metadata$RT[jj]) - FT_features$RT)
      valid = intersect(union(which(ms_error<=mz_search), which(ppm_error<=ppm_search)), which(rt_error<= rt_search/60))
      valid = unique(valid)
      
      if (length(valid)>0){
        kkk = kkk +1
        temp_feature =  ms2dat$metadata[jj,,drop=FALSE]
        temp_feature$ID = FT_features$ID[valid[1]]
        ms2_metadata_selected = rbind.data.frame(ms2_metadata_selected, temp_feature)
        ms2_sp_selected[[kkk]] = ms2dat$sp[[jj]]
        if (!is.null(FT_profile)){
          temp_profile = FT_profile[valid,,drop=FALSE]
          temp_profile = apply(temp_profile, 2, sum)
          ms2_profile_selected = rbind(ms2_profile_selected, temp_profile)
          ms2_profile_id_selected = c(ms2_profile_id_selected, FT_features$ID[valid[1]])
        }
      }
    }
    ms2dat = list(metadata = ms2_metadata_selected, sp = ms2_sp_selected)
    ms2profile = ms2_profile_selected
    ms2profile_id = ms2_profile_id_selected
  } else {
    ms2profile = NULL
    ms2profile_id = NULL
  }
  
  ######################
  ### Denoise ms2dat ###
  ######################
  
  NI = nrow(ms2dat$metadata)
  denoised_metadata = c()
  denoised_sp = list()
  NNN = 0 
  
  for (i in 1:NI){
    prec_mz = as.numeric(ms2dat$metadata$PEPMASS[i])
    sp = ms2dat$sp[[i]]
    if (nrow(sp)>2){
      new_sp = denoise_query_spectrum(sp, prec_mz, max_peaks, relative)
      if (nrow(new_sp)>2){
        NNN = NNN +1 
        denoised_metadata = rbind.data.frame(denoised_metadata, ms2dat$metadata[i,])
        denoised_sp[[NNN]] = new_sp
    }}
  }
  
  if (NNN == 0){stop("No valid MS2 scan available!")}         
 
  denoised_metadata$TIC = as.numeric(sapply(denoised_sp, function(x) sum(x[,2])))
  
  ###################################
  ### Transform spectra to matrix ###
  ###################################
  
  ms2dat = list(metadata = denoised_metadata, sp = denoised_sp)
  
  NI = nrow(ms2dat$metadata)
  IDList = unique(ms2dat$metadata$ID)
    
  if (NI>length(IDList)){
    message("Duplicated spectrum ID detected! Merging...")
    ms2dat = library_merger(ms2dat, method="common_peaks", consensus_window = mz_search*2,
                            params.ms.preprocessing = list(relative =relative, max_peaks = max_peaks))
  }
  
  # Align to matrix (to reduce processing time)
  
  ms2matrix = library2matrix(ms2dat, consensus_window = mz_search*2)
  
  # Data retrieval
  
  metadata = ms2dat$metadata
  splist = ms2dat$sp
  NI = nrow(metadata)
  IDList = metadata$ID
  MZList = as.numeric(metadata$PEPMASS)
  
  new_nodes = metadata
  new_network = c()
  
  ###############################
  ### Spectral Library Search ###
  ###############################
  
  if (!is.null(input_matrix)){
    
    new_nodes$MERGEION_ANNOTATION = "N/A"
    new_nodes$MERGEION_ANNOTATION_SCORES = 0
    new_nodes$MERGEION_ANNOTATION_FORMULA = "N/A"
    
    for (i in 1:NI){
      temp_spectrum = splist[[i]]
      
      temp_scores = library_similarity(query_spectrum = temp_spectrum, polarity = polarity, prec_mz = MZList[i], use.prec = TRUE,
                                       input_library = NULL, input_matrix = input_matrix,
                                       method = sim.method, prec_ppm_search = ppm_search, frag_mz_search = mz_search, min_frag_match = min.frag.match)
      
      if (!is.null(temp_scores)){
  
        temp_annotation = temp_scores[temp_scores[,2]>=min.score,,drop=FALSE]
        new_nodes$MERGEION_ANNOTATION[i] = paste0(temp_annotation[,1], collapse=":")
        new_nodes$MERGEION_ANNOTATION_SCORES[i] = paste0(round(temp_annotation[,2],3), collapse=":")
        new_nodes$MERGEION_ANNOTATION_FORMULA[i] = paste0(temp_annotation[,3], collapse=":")
      }
    }
  }
  
  #######################################
  ### Spectral similarity calculation ###
  #######################################
  
  for (i in 1:(NI-1)){
  
    temp_spectrum = splist[[i]]

    # Search part of library
    lib_range = (i+1):NI
    temp_ms2matrix = ms2matrix
    temp_ms2matrix$ref_lib$metadata = ms2matrix$ref_lib$metadata[lib_range,,drop=FALSE]
    temp_ms2matrix$ref_lib$sp = ms2matrix$ref_lib$sp[lib_range]
    temp_ms2matrix$db_profile =  ms2matrix$db_profile[,lib_range,drop=FALSE] 

    temp_scores = library_similarity(query_spectrum = temp_spectrum, polarity = polarity, prec_mz = MZList[i], use.prec = FALSE,
                  input_library = NULL, input_matrix = temp_ms2matrix,
                  method = sim.method, prec_ppm_search = ppm_search, frag_mz_search = mz_search, min_frag_match = min.frag.match)
    
    if (!is.null(temp_scores)){
      NSC = nrow(temp_scores)
      temp_network = cbind(ID1 = rep(IDList[i],NSC), ID2 = temp_scores[,1], MS2.Similarity = round(temp_scores[,2],3))  
      new_network = rbind.data.frame(new_network, temp_network)
    }
  }

  #######################
  ### Top K filtering ###
  #######################
  
  if (!is.null(new_network)){
    new_network = mutual_filter(new_network, topK = topK)
    if (nrow(new_network)==0){new_network = NULL}
  }
  
  #######################################
  ### Feature correlation calculation ###
  #######################################
      
  if (!is.null(ms2profile) & !is.null(new_network)){
    
    cor.scores = rep(0, nrow(new_network))
    for (j in 1:nrow(new_network)){
      II1 = ms2profile[which(as.character(ms2profile_id) == as.character(new_network$ID1[j]))[1],]
      II2 = ms2profile[which(as.character(ms2profile_id) == as.character(new_network$ID2[j]))[1],]
      cor.scores[j] = cor(II1, II2, method = cor.method)
    }
    new_network = cbind.data.frame(new_network, correlation = cor.scores)
  }
  
  ##################################
  ### Mass difference annotation ###
  ##################################
  
  if (!is.null(new_network)){
  
    reactionList = read.csv("https://raw.githubusercontent.com/daniellyz/MergeION2/master/inst/reactionList.txt", sep = "\t")
    reaction_annotated = rep("N/A", nrow(new_network))
    reaction_formula = rep("N/A", nrow(new_network))
  
    for (k in 1:nrow(new_network)){
      II1 = which(as.character(metadata$ID) == as.character(new_network$ID1[k]))[1]
      II2 = which(as.character(metadata$ID) == as.character(new_network$ID2[k]))[1]
      MZ1 = as.numeric(metadata$PEPMASS[II1])
      MZ2 = as.numeric(metadata$PEPMASS[II2])
      
      MDiff = abs(MZ1 - MZ2)
      MDiff_error = abs(reactionList$Mdiff - MDiff)
    
      if (min(MDiff_error)<=0.02){
        ind = which.min(MDiff_error)[1]
        reaction_annotated[k] = reactionList$Reaction.Name[ind]
        reaction_formula[k] = reactionList$Formula[ind]
      }
    }
    
    new_network = cbind.data.frame(new_network, reaction = reaction_annotated, reaction_formula = reaction_formula)
  }
  
  ###############################
  ### Final filtering network ###
  ###############################
  
  if (!is.null(new_network)){
    
    new_network = new_network[new_network[,3]>=min.score,,drop=FALSE]
    
    if ("correlation" %in% colnames(new_network)){
      new_network = new_network[abs(new_network$correlation)>=min.abs.cor,,drop=FALSE]
    }

    if (use.reaction){
      new_network = new_network[which(new_network$reaction!="N/A"),,drop=FALSE]
    }
  }
  
  return(list(nodes = new_nodes, network = new_network))
}
                  
                  
############################
### Internal functions:####
###########################

ppm_distance<-function(x,y){
  x = as.numeric(x)
  y = as.numeric(y)
  if (y>100){
    ppm = abs((x-y))/y*1000000
  } else {
    ppm = abs(x-y)
    ppm[ppm<0.01]=0
  }
  return(ppm)
}

denoise_query_spectrum<-function(sp, mz0, max_peak, min_relative){
  
  denoised_spectrum = matrix(c(0,0),1,2)
  
  if (nrow(sp)>0){
    
    # Filter top peaks:
    
    sp = sp[order(sp[,2], decreasing = T),,drop=FALSE]
    tops = min(max_peak, nrow(sp))  
    sp = sp[1:tops,,drop=FALSE]
    
    # Normalize to 100:
    
    sp1 = sp
    sp1[,2] = sp1[,2]/max(sp1[,2])*100
    
    # Relative Intensity filter:
    
    filter = which(sp1[,2]>=min_relative & sp1[,1]<mz0-1)
    sp = sp1
    sp = sp[filter,,drop=FALSE]
    
    # Check validity:
    
    if (nrow(sp)>0){
      sp = sp[order(sp[,1]),,drop=FALSE]
      denoised_spectrum = sp
    }
  }
  return(denoised_spectrum)
}

load_object <- function(file) {
  tmp <- new.env()
  load(file = file, envir = tmp)
  tmp[[ls(tmp)[1]]]
}

mutual_filter <- function(network, topK = 10){
  
  # The function keeps edges in the network if both nodes are among the topK of each other
  
  NR = nrow(network)
  temp_id = unique(c(network[,1], network[,2]))
  NI = length(temp_id)
  
  # Transformation to matrix:
  
  MMM = matrix(0, NI, NI)  
  colnames(MMM) = rownames(MMM) = temp_id
  
  from_ind = match(network[,1], temp_id)
  to_ind = match(network[,2], temp_id) # Index in the temp_ind
  
  for(x in 1:NR){
    MMM[from_ind[x], to_ind[x]] = as.numeric(network[x,3])
    MMM[to_ind[x], from_ind[x]] = as.numeric(network[x,3])
  }
  
  # Take topK of each row
  
  top_value_row = apply(MMM, 1, function(x) min(head(sort(x, decreasing=T), topK))) # Lowest value of topK
  top_value_column = apply(MMM, 2, function(x) min(head(sort(x, decreasing=T), topK)))
  
  for (x in 1:NI){
    tmp = MMM[x,]
    tmp[tmp<top_value_row] = 0
    MMM[x,] = tmp
    tmp = MMM[,x]
    tmp[tmp<top_value_column] = 0
    MMM[,x] = tmp
  }  
  
  MMM[lower.tri(MMM)] = 0 # Set to 0 due to symmetry
  
  # Transform matrix back to network
  
  valid = which(MMM>0, arr.ind = T)
  from_id = temp_id[valid[,1]]
  to_id = temp_id[valid[,2]]
  sim_score = MMM[valid]
  
  network_filtered = cbind.data.frame(ID1 = from_id, ID2 = to_id, MS2.Similarity = MMM[valid])
  
  return(network_filtered)
}

