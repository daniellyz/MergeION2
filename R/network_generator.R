#' Create feature-based molecular networks
#'
#' Generate feature-based molecular networks from raw LC-MS/MS file or spectral summary file, automatically annotate features in a spectral library
#'
#' @param raw_data_file Character. The LC-MS/MS file in mzML/mzXML format or MS/MS spectral summary file in mgf format. Check following link for more information about MS/MS spectral summary file: https://ccms-ucsd.github.io/GNPSDocumentation/featurebasedmolecularnetworking-with-mzmine2/
#' @param feature_table Character. The feature quantification table file. The file should be tab, comma or semi-colon separated txt, dat or csv format. It should contain at least 3 columns: LC-MS feature ID, m/z and RT that could be detected in the raw data file. It can also contain abundance of these features in samples. Check following link for more details about the format: https://ccms-ucsd.github.io/GNPSDocumentation/featurebasedmolecularnetworking-with-mzmine2/
#' @param input_library A list generated by the function library_generator() or the name of mgf/msp/RData spectral library file.
#' @param input_matrix Transformed spectral library by the function library2matrix. Used for MassBank or GNPS spectra library search. Please set to NULL otherwise
#' @param polarity character. Either "Positive" or "Negative". Ion mode of the LC-MS/MS file. 
#' @param params.search Parameters for clustering ions from raw_data_file and for searching in the spectral library. The list must contain following elements:
#' \itemize{
#'  \item{mz_search:}{ Numeric. Absolute mass tolerance in Da.}
#'  \item{ppm_search:}{ Numeric. Absolute mass tolerance in ppm.} 
#'  \item{rt_search":}{ Numeric. Absolute retention time tolerance in second.}
#' }
#' @param params.ms.preprocessing Parameters for post-processing scans in raw_data_file:
#' \itemize{
#'  \item{baseline:}{ Numeric. Absolute intensity threshold that is considered as a mass peak and written into the library.}
#'  \item{relative:}{ Numeric between 0 and 100. Relative intensity threshold of the highest peak in each spectrum, peaks above both absolute and relative thresholds are saved in the library.}
#'  \item{max_peaks:}{ Integer higher than 3. Maximum number of peaks kept per spectrum from the highest peak.}
#' }
#' @param params.similarity Parameters for MS/MS spectral similarity determination
#' \itemize{
#'  \item{method:}{Characeter.Similarity metrics for networking and spectral library search. Must be "Matches", "Pearson", "Spearman", "MassBank", "NIST". Please check function library_similarity for more details.}
#'  \item{use.prec:}{Boolean. Used for spectral library search. If set to TRUE, precursor mass is used to "pre-query" the library}
#'  \item{min_frag_match:}{Integer. Minimum matched peaks (or corresponding neutral losses) to make a match.}
#' }
#'@param params.correlation Parameters for feature correlation if feature quantification table is provided
#' \itemize{
#'  \item{method:}{Characeter. Correlation metrics. Must be "Pearson" or "Spearman".}
#'  \item{min.abs.cor:}{Numeric between 0 and 1. Minimum feature correlation between connected MS/MS features.}
#' }
#' 
#' @importFrom tools file_path_sans_ext
#' 
#' @export
#'

network_generator<-function(raw_data_file, feature_table = NULL, input_library = NULL, input_matrix = NULL, polarity = c("Positive", "Negative"),
                  params.search = list(mz_search = 0.005, ppm_search = 10, rt_search = 15),
                  params.ms.preprocessing = list(baseline = 1000, relative = 0.01, max_peaks = 200),
                  params.similarity = list(method = "Pearson", use.prec = FALSE, min_frag_match = 6),
                  params.correlation = list(method = "Spearman", min.abs.cor = 0.4)){
  
  options(stringsAsFactors = FALSE)
  options(warn=-1)

  mz_search = params.search$mz_search
  ppm_search = params.search$ppm_search
  rt_search = params.search$rt_search
  
  baseline = params.ms.preprocessing$baseline
  relative = params.ms.preprocessing$relative
  max_peaks = params.ms.preprocessing$max_peaks      
  
  sim.method = params.similarity$method
  use.prec = params.similarity$use.prec
  min.frag.match =  params.similarity$min_frag_match
  
  cor.method = params.correlation$method
  min.abs.cor = params.correlation$min.abs.cor
  
  ###################
  ### Check inputs: #
  ###################

  if (!file_ext(raw_data_file) %in% c("mzML", "mzXML", "mgf")){
    stop("The LC-MS/MS file for network generation must be in mgf, mzML or mzXML format!")
  }
                    
  if (file_ext(raw_data_file)=="mgf"){
    ms2dat = readMGF2(raw_data_file)}
  if (file_ext(raw_data_file)=="mzML" || file_ext(raw_data_file)=="mzXML"){
    ms2dat = readMZXML2(raw_data_file, polarity, ppm_search, rt_search, baseline)}
                    
  if (is.null(ms2dat$metadata)){stop("No feature is detected in raw_data_file!")}
  if (nrow(ms2dat$metadata)==0){stop("No feature is detected in raw_data_file!")}
         
  if (is.character(feature_table)){ 
    if (!file_ext(feature_table) %in% c("csv", "dat", "txt")){
      stop("The feature table must be in csv, dat and txt file!")
    }

    FT = read.csv(feature_table,sep=";",dec=".",header=T)
    if (ncol(FT)==1){FT = read.csv(feature_table,sep=",",dec=".",header=T)}  
    if (ncol(FT)==1){FT = read.csv(feature_table,sep="\t",dec=".",header=T)}  
    if (ncol(FT)<3){stop("Input feature quantification format not valid!")}
    
    FT_features = FT[,1:3] 
    colnames(FT_features)[1:3] = c("ID", "Mass", "RT")
    FT_features = apply(FT_features, 2, as.numeric)
    FT_features = data.frame(FT_features)
    
    if (ncol(FT)>8){
      FT_profile = FT[,4:ncol(FT)]
      FT_profile = apply(FT_profile, 2, as.numeric)
      FT_profile = data.matrix(FT_profile)
    } else {FT_profile = NULL}
  } else {
    FT_features = NULL
    FT_profile = NULL
  }
  
  if (is.null(input_matrix) & !is.null(input_library)){
    
    if (is.character(input_library)){
      if (file_ext(input_library)!="mgf" & file_ext(input_library)!="msp" & file_ext(input_library)!="RData"){
        stop("The input library must be mgf, msp or RData format!")
      }
    }
  
    if (is.character(input_library)){
      if (file_ext(input_library)=="mgf"){
        input_library = readMGF2(input_library)}
      if (file_ext(input_library)=="RData"){
        input_library = load_object(input_library)}
      if (file_ext(input_library)=="msp"){
        input_library = readMSP2(input_library)}
    }
  
    if (!is.null(input_library)){
      if (length(input_library)==2 & "complete" %in% names(input_library)){
        input_library = input_library$complete
      }
      if (length(input_library)!=2 || (!is.list(input_library$sp)) || !is.data.frame(input_library$metadata)){
        stop("Please make sure your input library is a valid output of library_generator()!")
      }
    }
    input_matrix = library2matrix(input_library, consensus_window = mz_search*2)
  } 
  
  if (!(polarity %in% c("Positive", "Negative"))){
    stop("Polarity must be either Positive or Negative")
  }
  
  #########################
  ### Pre-process ms2dat ##
  #########################

  # MSLEVEL and IONMODE filtering:
  
  if (!("MSLEVEL" %in% colnames(ms2dat$metadata))){ms2dat$metadata$MSLEVEL=2}
  if (!("IONMODE" %in% colnames(ms2dat$metadata))){ms2dat$metadata$IONMODE=polarity}
  if ("FEATURE_ID" %in% colnames(ms2dat$metadata)){ms2dat$metadata$ID=ms2dat$metadata$FEATURE_ID}        
  ms2dat$metadata$SCANS = 1:nrow(ms2dat$metadata)
  
  ms2dat = library_manager(ms2dat, query= c("MSLEVEL=2", paste0("IONMODE=",polarity)), logical = "AND")$SELECTED 
  
  # Match to feature table:
  
  if (!is.null(FT_features)){
    MDD = nrow(ms2dat$metadata)
    ms2_metadata_selected = c()
    ms2_profile_selected = c()
    ms2_profile_id_selected = c()
    ms2_sp_selected = list()
    kkk = 0
    
    for (jj in 1:MDD){
      ms_error = abs(as.numeric(ms2dat$metadata$PEPMASS[jj]) - FT_features$Mass)
      ppm_error = ppm_distance(FT_features$Mass, as.numeric(ms2dat$metadata$PEPMASS[jj]))
      rt_error = abs(as.numeric(ms2dat$metadata$RT[jj]) - FT_features$RT)
      valid = intersect(union(which(ms_error<=mz_search), which(ppm_error<=ppm_search)), which(rt_error<= rt_search/60))
      valid = unique(valid)
      
      if (length(valid)>0){
        kkk = kkk +1
        temp_feature =  ms2dat$metadata[jj,,drop=FALSE]
        temp_feature$ID = FT_features$ID[valid[1]]
        ms2_metadata_selected = rbind.data.frame(ms2_metadata_selected, temp_feature)
        ms2_sp_selected[[kkk]] = ms2dat$sp[[jj]]
        if (!is.null(FT_profile)){
          temp_profile = FT_profile[valid,,drop=FALSE]
          temp_profile = apply(temp_profile, 2, sum)
          ms2_profile_selected = rbind(ms2_profile_selected, temp_profile)
          ms2_profile_id_selected = c(ms2_profile_id_selected, FT_features$ID[valid[1]])
        }
      }
    }
    ms2dat = list(metadata = ms2_metadata_selected, sp = ms2_sp_selected)
    ms2profile = ms2_profile_selected
    ms2profile_id = ms2_profile_id_selected
  } else {
    ms2profile = NULL
    ms2profile_id = NULL
  }
  
  # Denoising and filtering empty MS2 spectra:
  
  NI = nrow(ms2dat$metadata)
  denoised_metadata = c()
  denoised_sp = list()
  NNN = 0 
  
  for (i in 1:NI){
    prec_mz = as.numeric(ms2dat$metadata$PEPMASS[i])
    sp = ms2dat$sp[[i]]
    if (nrow(sp)>2){
      new_sp = denoise_query_spectrum(sp, prec_mz, max_peaks, relative)
      if (nrow(new_sp)>2){
        NNN = NNN +1 
        denoised_metadata = rbind.data.frame(denoised_metadata, ms2dat$metadata[i,])
        denoised_sp[[NNN]] = new_sp
    }}
  }
  
  if (NNN == 0){stop("No valid MS2 scan available!")}         
 
  denoised_metadata$TIC = as.numeric(sapply(denoised_sp, function(x) sum(x[,2])))
  
  # Merge 
  
  ms2dat = list(metadata = denoised_metadata, sp = denoised_sp)
  
  NI = nrow(ms2dat$metadata)
  IDList = unique(ms2dat$metadata$ID)
    
  if (NI>length(IDList)){
    message("Duplicated spectrum ID detected! Merging...")
    ms2dat = library_merger(ms2dat, method="common_peaks", consensus_window = mz_search*2,
                            params.ms.preprocessing = list(relative =relative, max_peaks = max_peaks))
  }
  
  # Align to matrix (to reduce processing time)
  
  ms2matrix = library2matrix(ms2dat, consensus_window = mz_search*2)
  
  # Data retrieval
  
  metadata = ms2dat$metadata
  splist = ms2dat$sp
  NI = nrow(metadata)
  IDList = metadata$ID
  MZList = as.numeric(metadata$PEPMASS)
  
  new_nodes = metadata
  new_network = c()
  
  #######################################
  ### Spectral similarity calculation ###
  #######################################
  
  for (i in 1:(NI-1)){
  
    temp_spectrum = splist[[i]]

    # Search part of library
    lib_range = (i+1):NI
    temp_ms2matrix = ms2matrix
    temp_ms2matrix$ref_lib$metadata = ms2matrix$ref_lib$metadata[lib_range,,drop=FALSE]
    temp_ms2matrix$ref_lib$sp = ms2matrix$ref_lib$sp[lib_range]
    temp_ms2matrix$db_profile =  ms2matrix$db_profile[,lib_range,drop=FALSE] 

    temp_scores = library_similarity(query_spectrum = temp_spectrum, polarity = polarity, prec_mz = MZList[i], use.prec = FALSE,
                  input_library = NULL, input_matrix = temp_ms2matrix,
                  method = sim.method, prec_ppm_search = ppm_search, frag_mz_search = mz_search, min_frag_match = min.frag.match)
    
    if (!is.null(temp_scores)){
      NSC = nrow(temp_scores)
      temp_network = cbind(ID1 = rep(IDList[i],NSC), ID2 = temp_scores[,1], MS2.Similarity = round(temp_scores[,2],3))  
      new_network = rbind.data.frame(new_network, temp_network)
    }
  }
  
  #######################################
  ### Feature correlation calculation ###
  #######################################
      
  if (!is.null(ms2profile)){
    
    cor.scores = rep(0, nrow(new_network))
    for (j in 1:nrow(new_network)){
      II1 = ms2profile[which(as.character(ms2profile_id) == as.character(new_network$ID1[j]))[1],]
      II2 = ms2profile[which(as.character(ms2profile_id) == as.character(new_network$ID2[j]))[1],]
      cor.scores[j] = cor(II1, II2, method = cor.method)
    }
    new_network = cbind.data.frame(new_network, correlation = cor.scores)
    new_network = new_network[abs(new_network$correlation)>=min.abs.cor,,drop=FALSE]
  }
  
  ###############################
  ### Spectral Library Search ###
  ###############################
  
  if (!is.null(input_matrix)){
  
    new_nodes$MERGEION_ANNOTATION = "N/A"
    new_nodes$MERGEION_ANNOTATION_SCORES = 0
  
    for (i in 1:NI){
      temp_spectrum = splist[[i]]

      temp_scores = library_similarity(query_spectrum = temp_spectrum, polarity = polarity, prec_mz = MZList[i], use.prec = use.prec,
                                     input_library = NULL, input_matrix = input_matrix,
                                     method = sim.method, prec_ppm_search = ppm_search, frag_mz_search = mz_search, min_frag_match = min.frag.match)
      
      if (!is.null(temp_scores)){
        temp_max = min(10, nrow(temp_scores))
        temp_annotation = temp_scores[1:temp_max,,drop=FALSE]
        new_nodes$MERGEION_ANNOTATION[i] = paste0(temp_annotation[,1], collapse=":")
        new_nodes$MERGEION_ANNOTATION_SCORES[i] = paste0(round(temp_annotation[,2],3), collapse=":")
      }
    }
  }
  
  return(list(nodes = new_nodes, network = new_network))
}
                  
                  
############################
### Internal functions:####
###########################

ppm_distance<-function(x,y){
  x = as.numeric(x)
  y = as.numeric(y)
  if (y>100){
    ppm = abs((x-y))/y*1000000
  } else {
    ppm = abs(x-y)
    ppm[ppm<0.01]=0
  }
  return(ppm)
}

denoise_query_spectrum<-function(sp, mz0, max_peak, min_relative){
  
  denoised_spectrum = matrix(c(0,0),1,2)
  
  if (nrow(sp)>0){
    
    # Filter top peaks:
    
    sp = sp[order(sp[,2], decreasing = T),,drop=FALSE]
    tops = min(max_peak, nrow(sp))  
    sp = sp[1:tops,,drop=FALSE]
    
    # Normalize to 100:
    
    sp1 = sp
    sp1[,2] = sp1[,2]/max(sp1[,2])*100
    
    # Relative Intensity filter:
    
    filter = which(sp1[,2]>=min_relative & sp1[,1]<mz0-1)
    sp = sp1
    sp = sp[filter,,drop=FALSE]
    
    # Check validity:
    
    if (nrow(sp)>0){
      sp = sp[order(sp[,1]),,drop=FALSE]
      denoised_spectrum = sp
    }
  }
  return(denoised_spectrum)
}

load_object <- function(file) {
  tmp <- new.env()
  load(file = file, envir = tmp)
  tmp[[ls(tmp)[1]]]
}
