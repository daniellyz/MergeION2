#' Create feature-based molecular networks
#'
#' Generate feature-based molecular networks from raw LC-MS/MS file or spectral summary file, automatically annotate features in a spectral library
#'
#' @param raw_data_file Character. The LC-MS/MS file in mzML/mzXML format or MS/MS spectral summary file in mgf format. Check following link for more information about MS/MS spectral summary file: https://ccms-ucsd.github.io/GNPSDocumentation/featurebasedmolecularnetworking-with-mzmine2/
#' @param input_library A list generated by the function library_generator() or the name of mgf/msp/RData spectral library file.
#' @param input_matrix Transformed spectral library by the function library2matrix. Used for MassBank or GNPS spectra library search. Please set to NULL otherwise
#' @param polarity character. Either "Positive" or "Negative". Ion mode of the LC-MS/MS file. 
#' @param params.search Parameters for clustering ions from raw_data_file and for searching in the spectral library. The list must contain following elements:
#' \itemize{
#'  \item{mz_search:}{ Numeric. Absolute mass tolerance in Da.}
#'  \item{ppm_search:}{ Numeric. Absolute mass tolerance in ppm.} 
#'  \item{rt_search":}{ Numeric. Absolute retention time tolerance in second.}
#' }
#' @param params.ms.preprocessing Parameters for post-processing scans in raw_data_file:
#' \itemize{
#'  \item{baseline:}{ Numeric. Absolute intensity threshold that is considered as a mass peak and written into the library.}
#'  \item{relative:}{ Numeric between 0 and 100. Relative intensity threshold of the highest peak in each spectrum, peaks above both absolute and relative thresholds are saved in the library.}
#'  \item{max_peaks:}{ Integer higher than 3. Maximum number of peaks kept per spectrum from the highest peak.}
#' }
#' @param params.similarity Parameters for MS/MS spectral similarity determination
#' \itemize{
#'  \item{method:}{Characeter.Similarity metrics for networking and spectral library search. Must be "Matches", "Cosine", "Spearman", "Euclidean", "MassBank", "NIST". Please check function library_similarity for more details.}
#'  \item{use.prec:}{Boolean. Used for spectral library search. If set to TRUE, precursor mass is used to "pre-query" the library}
#'  \item{min_frag_match:}{Integer. Minimum matched peaks (or corresponding neutral losses) to make a match.}
#' }
#' 
#' @importFrom tools file_path_sans_ext
#' 
#' @export
#'
#'

network_generator<-function(raw_data_file, input_library = NULL, input_matrix = NULL, polarity = c("Positive", "Negative"),
                  params.search = list(mz_search = 0.005, ppm_search = 10, rt_seach = 15),
                  params.ms.preprocessing = list(baseline = 1000, relative =0.01, max_peaks = 200),
                  params.similarity = list(method = "Cosine", use.prec = FALSE, min_frag_match = 6)){
  
  options(stringsAsFactors = FALSE)
  options(warn=-1)

  mz_search = params.search$mz_search
  ppm_search = params.search$ppm_search
  rt_seach = params.search$rt_seach
  
  baseline = params.ms.preprocessing$baseline
  relative = params.ms.preprocessing$relative
  max_peaks = params.ms.preprocessing$max_peaks      
  
  sim.method = params.similarity$method
  use.prec = params.similarity$use.prec
  min.frag.match =  params.similarity$min_frag_match
  
  ###################
  ### Check inputs: #
  ###################

  if (!file_ext(raw_data_file) %in% c("mzML", "mzXML", "mgf")){
    stop("The LC-MS/MS file for network generation must be in mgf, mzML or mzXML format!")
  }
                    
  if (file_ext(raw_data_file)=="mgf"){
    ms2dat = readMGF2(raw_data_file)}
  if (file_ext(raw_data_file)=="mzML" || file_ext(raw_data_file)=="mzXML"){
    ms2dat = readMZXML2(raw_data_file, polarity, ppm_search, rt_search, baseline)}
                    
  if (is.null(ms2dat$metadata)){stop("No feature is detected in raw_data_file!")}
  if (nrow(ms2dat$metadata)==0){stop("No feature is detected in raw_data_file!")}
                    
  if (is.null(input_matrix) & !is.null(input_library)){
    
    if (is.character(input_library)){
      if (file_ext(input_library)!="mgf" & file_ext(input_library)!="msp" & file_ext(input_library)!="RData"){
        stop("The input library must be mgf, msp or RData format!")
      }
    }
  
    if (is.character(input_library)){
      if (file_ext(input_library)=="mgf"){
        input_library = readMGF2(input_library)}
      if (file_ext(input_library)=="RData"){
        input_library = load_object(input_library)}
      if (file_ext(input_library)=="msp"){
        input_library = readMSP2(input_library)}
    }
  
    if (!is.null(input_library)){
      if (length(input_library)==2 & "complete" %in% names(input_library)){
        input_library = input_library$complete
      }
      if (length(input_library)!=2 || (!is.list(input_library$sp)) || !is.data.frame(input_library$metadata)){
        stop("Please make sure your input library is a valid output of library_generator()!")
      }
    }
    input_matrix = library2matrix(input_library, consensus_window = mz_search*2)
  } 
  
  if (!(polarity %in% c("Positive", "Negative"))){
    stop("Polarity must be either Positive or Negative")
  }
  
  #########################
  ### Pre-process ms2dat ##
  #########################

  # MSLEVEL and IONMODE filtering:
  
  if (!("MSLEVEL" %in% colnames(ms2dat$metadata))){ms2dat$metadata$MSLEVEL=2}
  if (!("IONMODE" %in% colnames(ms2dat$metadata))){ms2dat$metadata$IONMODE=polarity}
  if ("FEATURE_ID" %in% colnames(ms2dat$metadata)){ms2dat$metadata$ID=ms2dat$metadata$FEATURE_ID}        
  ms2dat$metadata$SCANS = 1:nrow(ms2dat$metadata)
  
  ms2dat = library_manager(ms2dat, query= c("MSLEVEL=2", paste0("IONMODE=",polarity)), logical = "AND")$SELECTED 
      
  # Denoising and filtering empty MS2 spectra:
  
  NI = nrow(ms2dat$metadata)
  denoised_metadata = c()
  denoised_sp = list()
  NNN = 0 
  
  for (i in 1:NI){
    prec_mz = as.numeric(ms2dat$metadata$PEPMASS[i])
    sp = ms2dat$sp[[i]]
    if (nrow(sp)>2){
      new_sp = denoise_query_spectrum(sp, prec_mz, max_peaks, relative)
      if (nrow(new_sp)>2){
        NNN = NNN +1 
        denoised_metadata = rbind.data.frame(denoised_metadata, ms2dat$metadata[i,])
        denoised_sp[[NNN]] = new_sp
    }}
  }
  
  if (NNN == 0){stop("No valid MS2 scan available!")}         
 
  denoised_metadata$TIC = as.numeric(sapply(denoised_sp, function(x) sum(x[,2])))
  
  # Merge 
  
  ms2dat = list(metadata = denoised_metadata, sp = denoised_sp)
  
  NI = nrow(ms2dat$metadata)
  IDList = unique(ms2dat$metadata$ID)
    
  if (NI>length(IDList)){
    message("Duplicated spectrum ID detected! Merging...")
    ms2dat = library2matrix(ms2dat, consensus_window = mz_search*2)$ref_lib
  }
  
  # Output
  
  metadata = ms2dat$metadata
  splist = ms2dat$sp
  NI = nrow(metadata)
  IDList = metadata$ID
  MZList = as.numeric(metadata$PEPMASS)
  
  new_nodes = metadata
  new_network = c()
  
  #######################################
  ### Spectral similarity calculation ###
  #######################################
  
  for (i in 1:(NI-1)){
    temp_spectrum = splist[[i]]
    temp_lib = list(metadata = metadata[(i+1):NI,,drop=FALSE], sp = splist[(i+1):NI])
    
    temp_scores = library_similarity(query_spectrum = temp_spectrum, polarity = polarity, prec_mz = MZList[i], use.prec = FALSE,
                  input_library = temp_lib, input_matrix = NULL,
                  method = sim.method, prec_ppm_search = ppm_search, frag_mz_search = mz_search, min_frag_match = min.frag.match)
    
    if (!is.null(temp_scores)){
      NSC = nrow(temp_scores)
      temp_network = cbind(ID1 = rep(IDList[i],NSC), ID2 = temp_scores[,1], MS2.Similarity = temp_scores[,2])  
      new_network = rbind.data.frame(new_network, temp_network)
    }
  }
    
  ###############################
  ### Spectral Library Search ###
  ###############################
  
  if (!is.null(input_matrix)){
  
    new_nodes$MERGEION_ANNOTATION = "N/A"
    new_nodes$MERGEION_ANNOTATION_SCORES = 0
  
    for (i in 1:NI){
      temp_spectrum = splist[[i]]

      temp_scores = library_similarity(query_spectrum = temp_spectrum, polarity = polarity, prec_mz = MZList[i], use.prec = use.prec,
                                     input_library = NULL, input_matrix = input_matrix,
                                     method = sim.method, prec_ppm_search = ppm_search, frag_mz_search = mz_search, min_frag_match = min.frag.match)
      if (!is.null(temp_scores)){
        new_nodes$MERGEION_ANNOTATION[i] = paste0(temp_scores[,1], collapse=":")
        new_nodes$MERGEION_ANNOTATION_SCORES[i] = paste0(round(temp_scores[,2],2), collapse=":")
      }
    }
  }
  
  return(list(nodes = new_nodes, network = new_network))
}
                  
                  
############################
### Internal functions:####
###########################

denoise_query_spectrum<-function(sp, mz0, max_peak, min_relative){
  
  denoised_spectrum = matrix(c(0,0),1,2)
  
  if (nrow(sp)>0){
    
    # Filter top peaks:
    
    sp = sp[order(sp[,2], decreasing = T),,drop=FALSE]
    tops = min(max_peak, nrow(sp))  
    sp = sp[1:tops,,drop=FALSE]
    
    # Normalize to 100:
    
    sp1 = sp
    sp1[,2] = sp1[,2]/max(sp1[,2])*100
    
    # Relative Intensity filter:
    
    filter = which(sp1[,2]>=min_relative & sp1[,1]<mz0-1)
    sp = sp1
    sp = sp[filter,,drop=FALSE]
    
    # Check validity:
    
    if (nrow(sp)>0){
      sp = sp[order(sp[,1]),,drop=FALSE]
      denoised_spectrum = sp
    }
  }
  return(denoised_spectrum)
}

load_object <- function(file) {
  tmp <- new.env()
  load(file = file, envir = tmp)
  tmp[[ls(tmp)[1]]]
}
